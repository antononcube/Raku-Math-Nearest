use v6.d;
use Test;

use lib <. lib>;

use Math::Nearest;

plan *;

my @points = ([(^100).rand, (^100).rand] xx 100).unique;

## 1
my $finder1;
$finder1 = Math::Nearest::Finder.new(@points);
isa-ok $finder1, Math::Nearest::Finder:D;

## 2
my @searchPoint1 = |@points.head;
is-deeply $finder1.nearest(@searchPoint1).Array, [@searchPoint1,];

## 3
is-deeply $finder1.nearest-within-ball(@searchPoint1, 12, prop => <point>), $finder1.nearest(@searchPoint1, (Whatever, 12));

## 4
is-deeply $finder1.nearest(@searchPoint1, 3), $finder1.nearest(@searchPoint1, (3, Whatever));

## 5
is-deeply $finder1.nearest(@searchPoint1, 5).sort, $finder1.nearest(@searchPoint1, (5, 60)).sort;

## 6
# Make verification test with direct scanning of @points.
my @nns6 = @points.sort({ sqrt [+] ($_.Array Z- @searchPoint1).map(* ** 2) });
is-deeply $finder1.nearest(@searchPoint1, 12), @nns6[^12];

done-testing;
